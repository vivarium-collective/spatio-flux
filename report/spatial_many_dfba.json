{
    "state": {
        "global_time": "0.0",
        "fields": {
            "glucose": {
                "list": [
                    [
                        7.39890668495204,
                        5.9821512904818945,
                        18.963958963175138,
                        9.147854525908532,
                        12.133489499378094
                    ],
                    [
                        4.734723061487037,
                        4.056106834087081,
                        0.921953590535336,
                        19.502892815358326,
                        0.1995155326269349
                    ],
                    [
                        2.933562425883709,
                        9.309924139010612,
                        15.916483524080668,
                        5.176574386418937,
                        18.168753730138285
                    ],
                    [
                        0.8423459544769241,
                        17.75976670105164,
                        16.823685676306695,
                        3.2611474531816365,
                        15.24965467871769
                    ],
                    [
                        5.6850993135937085,
                        8.581627663201239,
                        1.9153819128849836,
                        6.7284568752665646,
                        14.11340261374966
                    ],
                    [
                        7.598806804394613,
                        9.26923091743135,
                        8.13584295476775,
                        5.712314080717209,
                        11.470452236372681
                    ],
                    [
                        16.249060689379814,
                        0.2657864758202533,
                        14.434339807051275,
                        4.640449130370429,
                        6.670648781382383
                    ],
                    [
                        8.729954059329753,
                        13.123940501139161,
                        13.129870716405156,
                        9.206318545750795,
                        18.024706287899967
                    ],
                    [
                        7.035009571265358,
                        4.2614160638485865,
                        1.2069882401679233,
                        5.767490374852855,
                        10.611973852833094
                    ],
                    [
                        17.170955196895168,
                        12.077909370676771,
                        17.482325736514422,
                        11.942538312076895,
                        17.920717206784214
                    ]
                ],
                "data": "float",
                "shape": [
                    10,
                    5
                ]
            },
            "acetate": {
                "list": [
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ],
                    [
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                ],
                "data": "float",
                "shape": [
                    10,
                    5
                ]
            },
            "biomass": {
                "list": [
                    [
                        0.09100966115231562,
                        0.08288714916575565,
                        0.0731149759945246,
                        0.09164028272421056,
                        0.016770736350901583
                    ],
                    [
                        0.03810178721632064,
                        0.06958076090778956,
                        0.0976983624624823,
                        0.009732712234502672,
                        0.048949126802853876
                    ],
                    [
                        0.04291559362852099,
                        0.049764928503345456,
                        0.008303701459209624,
                        0.0872737999936659,
                        0.037820973525391134
                    ],
                    [
                        0.0021707797902051906,
                        0.07012678879319119,
                        0.053192322111210215,
                        0.022330265292187557,
                        0.05271375598109587
                    ],
                    [
                        0.08264081894662831,
                        0.05507331522817656,
                        0.08126836215111283,
                        0.07791559694948905,
                        0.004569173131980686
                    ],
                    [
                        0.021331308370832348,
                        0.05212897351969386,
                        0.035193948332776795,
                        0.03946464168561769,
                        0.02858919758399292
                    ],
                    [
                        0.05327411565224524,
                        0.05074193756204274,
                        0.0453837516432426,
                        0.03897493624869286,
                        0.023728713867989838
                    ],
                    [
                        0.017027464112626213,
                        0.00503810129154364,
                        0.06086809449831129,
                        0.07703966164980391,
                        0.0904605437900245
                    ],
                    [
                        0.0971879687283792,
                        0.06749639881087782,
                        0.07999680300602476,
                        0.034271553154505786,
                        0.09494469130286888
                    ],
                    [
                        0.08506989915466352,
                        0.059119952504443275,
                        0.07088895214799326,
                        0.00886454979546213,
                        0.09096348192524484
                    ]
                ],
                "data": "float",
                "shape": [
                    10,
                    5
                ]
            }
        },
        "spatial_dfba": {
            "dFBA[0,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[0,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[0,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[0,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[0,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            0,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            0,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        0,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[1,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[1,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[1,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[1,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[1,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            1,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            1,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        1,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[2,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[2,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[2,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[2,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[2,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            2,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            2,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        2,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[3,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[3,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[3,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[3,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[3,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            3,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            3,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        3,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[4,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[4,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[4,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[4,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[4,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            4,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            4,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        4,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[5,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[5,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[5,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[5,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[5,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            5,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            5,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        5,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[6,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[6,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[6,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[6,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[6,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            6,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            6,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        6,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[7,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[7,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[7,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[7,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[7,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            7,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            7,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        7,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[8,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[8,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[8,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[8,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[8,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            8,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            8,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        8,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[9,0]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        0
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            0
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            0
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        0
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[9,1]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        1
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            1
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            1
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        1
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[9,2]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        2
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            2
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            2
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        2
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[9,3]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        3
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            3
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            3
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        3
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            },
            "dFBA[9,4]": {
                "inputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        4
                    ]
                },
                "outputs": {
                    "substrates": {
                        "glucose": [
                            "..",
                            "fields",
                            "glucose",
                            9,
                            4
                        ],
                        "acetate": [
                            "..",
                            "fields",
                            "acetate",
                            9,
                            4
                        ]
                    },
                    "biomass": [
                        "..",
                        "fields",
                        "biomass",
                        9,
                        4
                    ]
                },
                "interval": 1.0,
                "address": "local:DynamicFBA",
                "config": {
                    "model_file": "textbook",
                    "kinetic_params": {
                        "glucose": [
                            "0.5",
                            "1.0"
                        ],
                        "acetate": [
                            "0.5",
                            "2.0"
                        ]
                    },
                    "substrate_update_reactions": {
                        "glucose": "EX_glc__D_e",
                        "acetate": "EX_ac_e"
                    },
                    "bounds": {
                        "EX_o2_e": {
                            "lower": "-2.0",
                            "upper": "!nil"
                        },
                        "ATPM": {
                            "lower": "1.0",
                            "upper": "1.0"
                        }
                    }
                },
                "shared": null
            }
        },
        "emitter": {
            "inputs": {
                "global_time": [
                    "global_time"
                ],
                "fields": [
                    "fields"
                ]
            },
            "outputs": null,
            "address": "local:ram-emitter",
            "config": {
                "emit": {
                    "global_time": "any",
                    "fields": "any"
                }
            }
        }
    },
    "composition": {
        "global_time": {
            "_type": "float",
            "_check": "check_float",
            "_apply": "accumulate",
            "_serialize": "to_string",
            "_description": "64-bit floating point precision number",
            "_default": 0.0,
            "_deserialize": "deserialize_float",
            "_divide": "divide_float",
            "_dataclass": "dataclass_float",
            "_inherit": [
                "number"
            ]
        },
        "fields": {
            "_type": "map",
            "_default": {},
            "_generate": "generate_map",
            "_apply": "apply_map",
            "_serialize": "serialize_map",
            "_deserialize": "deserialize_map",
            "_resolve": "resolve_map",
            "_dataclass": "dataclass_map",
            "_check": "check_map",
            "_slice": "slice_map",
            "_fold": "fold_map",
            "_divide": "divide_map",
            "_sort": "sort_map",
            "_type_parameters": [
                "value"
            ],
            "_description": "flat mapping from keys of strings to values of any type",
            "_graphviz": "graphviz_map",
            "_value": {
                "_type": "array",
                "_default": "default_array",
                "_check": "check_array",
                "_slice": "slice_array",
                "_apply": "apply_array",
                "_serialize": "serialize_array",
                "_deserialize": "deserialize_array",
                "_dataclass": "dataclass_array",
                "_resolve": "resolve_array",
                "_bind": "bind_array",
                "_type_parameters": [
                    "shape",
                    "data"
                ],
                "_description": "an array of arbitrary dimension",
                "_shape": [
                    10,
                    5
                ],
                "_data": "positive_float"
            }
        },
        "spatial_dfba": {
            "dFBA[0,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[0,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[0,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[0,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[0,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[1,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[1,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[1,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[1,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[1,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[2,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[2,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[2,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[2,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[2,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[3,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[3,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[3,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[3,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[3,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[4,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[4,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[4,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[4,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[4,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[5,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[5,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[5,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[5,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[5,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[6,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[6,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[6,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[6,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[6,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[7,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[7,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[7,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[7,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[7,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[8,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[8,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[8,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[8,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[8,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[9,0]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[9,1]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[9,2]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[9,3]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            },
            "dFBA[9,4]": {
                "_type": "process",
                "_default": "default_edge",
                "_generate": "generate_edge",
                "_apply": "apply_process",
                "_serialize": "serialize_process",
                "_deserialize": "deserialize_process",
                "_dataclass": "dataclass_edge",
                "_check": "check_process",
                "_slice": "slice_edge",
                "_inputs": {
                    "substrates": "map[positive_float]",
                    "biomass": "positive_float"
                },
                "_outputs": {
                    "substrates": "map[float]",
                    "biomass": "float"
                },
                "_description": "",
                "inputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "outputs": {
                    "_type": "wires",
                    "_default": "default_tree",
                    "_generate": "generate_tree",
                    "_check": "check_tree",
                    "_slice": "slice_tree",
                    "_apply": "apply_tree",
                    "_serialize": "serialize_tree",
                    "_deserialize": "deserialize_tree",
                    "_dataclass": "dataclass_tree",
                    "_fold": "fold_tree",
                    "_divide": "divide_tree",
                    "_resolve": "resolve_tree",
                    "_type_parameters": [
                        "leaf"
                    ],
                    "_description": "mapping from str to some type in a potentially nested form",
                    "_leaf": {
                        "_type": "path",
                        "_default": [],
                        "_check": "check_list",
                        "_slice": "slice_list",
                        "_apply": "apply_path",
                        "_serialize": "serialize_list",
                        "_deserialize": "deserialize_list",
                        "_dataclass": "dataclass_list",
                        "_fold": "fold_list",
                        "_divide": "divide_list",
                        "_type_parameters": [
                            "element"
                        ],
                        "_description": "general list type (or sublists)",
                        "_element": {
                            "_type": "mark",
                            "_apply": "apply_mark",
                            "_check": "check_mark",
                            "_deserialize": "deserialize_mark",
                            "_resolve": "resolve_mark"
                        },
                        "_inherit": [
                            "list[mark]"
                        ]
                    },
                    "_inherit": [
                        "tree[path]"
                    ]
                },
                "_graphviz": "graphviz_edge",
                "_inherit": [
                    "edge"
                ],
                "_fold": "fold_visit",
                "_divide": "divide_process",
                "interval": {
                    "_type": "interval",
                    "_check": "check_float",
                    "_apply": "set",
                    "_serialize": "to_string",
                    "_description": "64-bit floating point precision number",
                    "_default": "1.0",
                    "_deserialize": "deserialize_float",
                    "_divide": "divide_float",
                    "_dataclass": "dataclass_float",
                    "_inherit": [
                        "float"
                    ]
                },
                "address": {
                    "_type": "protocol",
                    "_default": "",
                    "_check": "check_string",
                    "_apply": "replace",
                    "_serialize": "serialize_string",
                    "_deserialize": "deserialize_string",
                    "_dataclass": "dataclass_string",
                    "_description": "64-bit integer",
                    "_inherit": [
                        "string"
                    ]
                },
                "config": {
                    "_type": "quote",
                    "_deserialize": "deserialize_quote",
                    "_default": "default_quote",
                    "_generate": "generate_quote",
                    "_sort": "sort_quote",
                    "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                    "_graphviz": "graphviz_none"
                },
                "shared": {
                    "_type": "map",
                    "_default": {},
                    "_generate": "generate_map",
                    "_apply": "apply_map",
                    "_serialize": "serialize_map",
                    "_deserialize": "deserialize_map",
                    "_resolve": "resolve_map",
                    "_dataclass": "dataclass_map",
                    "_check": "check_map",
                    "_slice": "slice_map",
                    "_fold": "fold_map",
                    "_divide": "divide_map",
                    "_sort": "sort_map",
                    "_type_parameters": [
                        "value"
                    ],
                    "_description": "flat mapping from keys of strings to values of any type",
                    "_graphviz": "graphviz_map",
                    "_value": {
                        "_type": "step",
                        "_default": "default_edge",
                        "_generate": "generate_edge",
                        "_apply": "apply_process",
                        "_serialize": "serialize_process",
                        "_deserialize": "deserialize_step",
                        "_dataclass": "dataclass_edge",
                        "_check": "check_process",
                        "_slice": "slice_edge",
                        "_type_parameters": [
                            "inputs",
                            "outputs"
                        ],
                        "_description": "",
                        "inputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "outputs": {
                            "_type": "wires",
                            "_default": "default_tree",
                            "_generate": "generate_tree",
                            "_check": "check_tree",
                            "_slice": "slice_tree",
                            "_apply": "apply_tree",
                            "_serialize": "serialize_tree",
                            "_deserialize": "deserialize_tree",
                            "_dataclass": "dataclass_tree",
                            "_fold": "fold_tree",
                            "_divide": "divide_tree",
                            "_resolve": "resolve_tree",
                            "_type_parameters": [
                                "leaf"
                            ],
                            "_description": "mapping from str to some type in a potentially nested form",
                            "_leaf": {
                                "_type": "path",
                                "_default": [],
                                "_check": "check_list",
                                "_slice": "slice_list",
                                "_apply": "apply_path",
                                "_serialize": "serialize_list",
                                "_deserialize": "deserialize_list",
                                "_dataclass": "dataclass_list",
                                "_fold": "fold_list",
                                "_divide": "divide_list",
                                "_type_parameters": [
                                    "element"
                                ],
                                "_description": "general list type (or sublists)",
                                "_element": {
                                    "_type": "mark",
                                    "_apply": "apply_mark",
                                    "_check": "check_mark",
                                    "_deserialize": "deserialize_mark",
                                    "_resolve": "resolve_mark"
                                },
                                "_inherit": [
                                    "list[mark]"
                                ]
                            },
                            "_inherit": [
                                "tree[path]"
                            ]
                        },
                        "_graphviz": "graphviz_edge",
                        "_inherit": [
                            "edge"
                        ],
                        "_fold": "fold_visit",
                        "_divide": "divide_process",
                        "address": {
                            "_type": "protocol",
                            "_default": "",
                            "_check": "check_string",
                            "_apply": "replace",
                            "_serialize": "serialize_string",
                            "_deserialize": "deserialize_string",
                            "_dataclass": "dataclass_string",
                            "_description": "64-bit integer",
                            "_inherit": [
                                "string"
                            ]
                        },
                        "config": {
                            "_type": "quote",
                            "_deserialize": "deserialize_quote",
                            "_default": "default_quote",
                            "_generate": "generate_quote",
                            "_sort": "sort_quote",
                            "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                            "_graphviz": "graphviz_none"
                        }
                    }
                }
            }
        },
        "emitter": {
            "_type": "step",
            "_default": "default_edge",
            "_generate": "generate_edge",
            "_apply": "apply_process",
            "_serialize": "serialize_process",
            "_deserialize": "deserialize_step",
            "_dataclass": "dataclass_edge",
            "_check": "check_process",
            "_slice": "slice_edge",
            "_inputs": {
                "global_time": "any",
                "fields": "any"
            },
            "_outputs": null,
            "_description": "",
            "inputs": {
                "_type": "wires",
                "_default": "default_tree",
                "_generate": "generate_tree",
                "_check": "check_tree",
                "_slice": "slice_tree",
                "_apply": "apply_tree",
                "_serialize": "serialize_tree",
                "_deserialize": "deserialize_tree",
                "_dataclass": "dataclass_tree",
                "_fold": "fold_tree",
                "_divide": "divide_tree",
                "_resolve": "resolve_tree",
                "_type_parameters": [
                    "leaf"
                ],
                "_description": "mapping from str to some type in a potentially nested form",
                "_leaf": {
                    "_type": "path",
                    "_default": [],
                    "_check": "check_list",
                    "_slice": "slice_list",
                    "_apply": "apply_path",
                    "_serialize": "serialize_list",
                    "_deserialize": "deserialize_list",
                    "_dataclass": "dataclass_list",
                    "_fold": "fold_list",
                    "_divide": "divide_list",
                    "_type_parameters": [
                        "element"
                    ],
                    "_description": "general list type (or sublists)",
                    "_element": {
                        "_type": "mark",
                        "_apply": "apply_mark",
                        "_check": "check_mark",
                        "_deserialize": "deserialize_mark",
                        "_resolve": "resolve_mark"
                    },
                    "_inherit": [
                        "list[mark]"
                    ]
                },
                "_inherit": [
                    "tree[path]"
                ]
            },
            "outputs": {
                "_type": "wires",
                "_default": "default_tree",
                "_generate": "generate_tree",
                "_check": "check_tree",
                "_slice": "slice_tree",
                "_apply": "apply_tree",
                "_serialize": "serialize_tree",
                "_deserialize": "deserialize_tree",
                "_dataclass": "dataclass_tree",
                "_fold": "fold_tree",
                "_divide": "divide_tree",
                "_resolve": "resolve_tree",
                "_type_parameters": [
                    "leaf"
                ],
                "_description": "mapping from str to some type in a potentially nested form",
                "_leaf": {
                    "_type": "path",
                    "_default": [],
                    "_check": "check_list",
                    "_slice": "slice_list",
                    "_apply": "apply_path",
                    "_serialize": "serialize_list",
                    "_deserialize": "deserialize_list",
                    "_dataclass": "dataclass_list",
                    "_fold": "fold_list",
                    "_divide": "divide_list",
                    "_type_parameters": [
                        "element"
                    ],
                    "_description": "general list type (or sublists)",
                    "_element": {
                        "_type": "mark",
                        "_apply": "apply_mark",
                        "_check": "check_mark",
                        "_deserialize": "deserialize_mark",
                        "_resolve": "resolve_mark"
                    },
                    "_inherit": [
                        "list[mark]"
                    ]
                },
                "_inherit": [
                    "tree[path]"
                ]
            },
            "_graphviz": "graphviz_edge",
            "_inherit": [
                "edge"
            ],
            "_fold": "fold_visit",
            "_divide": "divide_process",
            "address": {
                "_type": "protocol",
                "_default": "",
                "_check": "check_string",
                "_apply": "replace",
                "_serialize": "serialize_string",
                "_deserialize": "deserialize_string",
                "_dataclass": "dataclass_string",
                "_description": "64-bit integer",
                "_inherit": [
                    "string"
                ]
            },
            "config": {
                "_type": "quote",
                "_deserialize": "deserialize_quote",
                "_default": "default_quote",
                "_generate": "generate_quote",
                "_sort": "sort_quote",
                "_description": "protect a schema from generation, ie in the config for a nested composite which has type information we only want to evaluate inside of the composite",
                "_graphviz": "graphviz_none"
            },
            "instance": {
                "_type": "any",
                "_default": "default_any",
                "_slice": "slice_any",
                "_apply": "apply_any",
                "_check": "check_any",
                "_sort": "sort_any",
                "_generate": "generate_any",
                "_serialize": "serialize_any",
                "_deserialize": "deserialize_any",
                "_dataclass": "dataclass_any",
                "_resolve": "resolve_any",
                "_fold": "fold_any",
                "_bind": "bind_any",
                "_divide": "divide_any",
                "_graphviz": "graphviz_any"
            }
        }
    }
}